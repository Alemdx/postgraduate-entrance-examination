# 死锁

[TOC]

## 死锁的概念

多个进程因竞争资源而造成的相互等待。各进程相互等待对方手里的资源

### 饥饿

长期得不到想要的资源

|        | 共同点               | 区别                                                         |
| ------ | -------------------- | ------------------------------------------------------------ |
| 死锁   | 进程无法顺利向前推进 | 1.至少有两个或两个以上的进程同时发生死锁。<br />2.发生死锁的进程一定处于阻塞态 |
| 饥饿   | 进程无法顺利向前推进 | 1.可能只有一个进程发生饥饿<br />2.发生饥饿的进程可能是阻塞态也可能是就绪态 |
| 死循环 | 进程无法顺利向前推进 | 死循环是被管理者的问题（有可能是运行态的），不是操作系统负责解决的问题 |

## 死锁产生的原因

### 互斥条件

一个资源只能由一个进程所占有

### 不剥夺条件

只能主动释放，不能被其他进程抢走

### 请求并保持条件

保持自己资源不放的同时，请求其他资源

### 循环等待条件

存在一种资源的循环等待链

**发送死锁的时候一定有资源的循环等待**

**发生循环等待时未必死锁**

+ 同类型的有一个可以替代的资源

## 死锁的预防（静态的，可以提前设定）

破坏死锁的四个必要条件就可以了。（但是四个必要条件有一个没法完全破坏啊？）

### 互斥条件

把互斥使用的资源改成允许共享使用(SPOOLing技术)

### 不剥夺条件

改成可剥夺的。

它得不到其余的资源，就释放自己的资源

### 请求和保持条件

采用静态分配方法。**在运行前申请完所有需要的资源。**

资源利用率低，会导致某些进程饥饿

顺序资源分配法

### 循环等待条件

顺序资源分配法

每个进程必须按资源递增的顺序请求资源，**只有一个进程占有小编号的资源时，才有资格申请更大编号的资源**。

缺点：

1. 不方便增加新的资源
2. 资源的顺序可能和编号不一致，可能导致资源浪费。
3. 用户编程麻烦

## 死锁的避免（动态的，在运行时解决）

**试分配**，如果不会发送死锁就执行

### 安全序列

系统按照这种顺序分配资源，则每个进程都能顺利完成。只要有一个安全序列，系统就是安全的。注意**并不是所有的不安全状态都是死锁的。**

### 银行家算法

进程在提出资源申请时，判断这次分配是否会导致系统进入不安全状态。如果会进入不安全状态，则阻塞。

### 算法实现

定义Max数组表示最大需求，Allocation表示已经分配，Need表示最多还需要多少资源，Available表示剩余多少资源。Request表示某个进程向系统申请需要多少资源。

**如果Available>=need，则现在的Available=Availble+Allocation**

预判分配给那个进程资源之后会不会进入不安全状态。如果会进入，则不分配该资源

## 死锁的检测

**不会进行实际的分配工作。**

+ 定义一种类似于图的数据结构
  + 资源结点
  + 进程结点
+ 尝试满足某个进程的需求（顶点V）
+ 该进程需求满足后，消除所有与其相邻的边，依次如此重复
+ 如果最终能消除所有的边，则这个图是完全可以简化的。则此时一定没有发生死锁。如果最终不能消除所有边，那么此时就发生了死锁。
+ 进程指向资源的边称为**申请边**，资源向进程的边称为**分配边**

## 死锁的解除

1. 资源剥夺法
   1. 挂起死锁进程，将其分配给其他进程。
2. 撤销进程法
   1. 撤销部分死锁或全部死锁进程。
3. 进程回退法