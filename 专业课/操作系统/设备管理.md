# 设备管理

[TOC]

## 设备的分类

### IO设备按交换信息的单位分类

**块设备：**

+ 磁盘等，传输的基本单位是块

+ 传输快，可寻址

**字符设备：**

+ 鼠标键盘这种
+ 传输慢，不可寻址，采用中断驱动的方式

## I/O控制器

用于实现CPU对IO设备的控制

### 组成

1. CPU与控制器之间的接口
2. IO逻辑
3. 控制器与设备之间的接口

### 功能

1. 接收识别cpu发出的命令	
   1. 控制器中有控制寄存器，存放命令和参数

2. 向cpu报告设备的状态
   1. 状态寄存器，表示IO设备当前的状态

3. 数据交换
   1. 数据寄存器，暂时存放CPU发过来的数据。存放要发送的数据

4. 地址识别
   1. IO控制器中的寄存器有地址，用于判断使用哪个寄存器

### 编址

#### 内存映像IO

控制器中的寄存器与内存地址统一编址。

用对内存操作的指令对控制器进行操作。

#### 寄存器独立编址

控制器中的寄存器采用单独的地址。

需要专门的指令来控制操作控制器。

## IO控制方式

关注：

1. 完成一次读写操作的流程
2. CPU干预的频率
3. 数据传送的单位
4. 数据的流向
5. 主要优缺点

### 程序直接控制方式

1. 轮询
2. 干预频繁，不断轮询
3. 每次读写一个字
4. 读：IO设备->cpu->内存  写： 反过来
5. 实现简单；但CPU利用率低

### 中断驱动方式

1. 中断，发出命令后阻塞IO进程，执行别的进程
2. 干预频率低
3. 每次读入或写入一个字大小的数据
4. 读：IO设备->cpu->内存  写： 反过来
5. 让CPU和IO并行工作。由于每次只能传输一个字，大量数据会频繁中断，消耗cpu

### DMA方式

直接存储器存取，主要用于块设备的控制

1. CPU发送命令交给DMA去做，DMA做完之后通过中断的形式告知CPU
2. 开始和结束时才需要CPU干预
3. 一个或多个块（连续的块）
4. IO->内存  内存->IO
5. CPU利用率提升 但如果要实现离散存储，CPU就需要发出多条指令

### 通道控制方式

是一种**硬件**，弱鸡版的CPU。通道可以识别执行一系列通道指令。

和DMA相比，区别在于可以一次性将一堆事情都丢给通道执行。

与CPU共享内存。

## IO软件层次结构

### 用户层IO软件

+ 为用户提供接口
+ 例如IO相关的库函数

#### 具体实现

+ SPOOLing技术

### 设备独立性软件

+ 提供系统调用

+ 设备的保护
+ 差错处理
+ 设备的分配与回收
+ 数据缓冲区管理
+ 建立逻辑设备名到物理设备名之间的映射关系，根据设备类型选择调用相应的驱动程序
  + 为整个系统设计一张逻辑设备表
  + 为每个用户设置一张逻辑设备表
+ **屏蔽设备之间的差异，向用户提供统一接口。一个操作系统只有一个**

#### 具体实现

IO调度（调度算法），设备保护（使用权限），设备分配与回收，缓冲区管理

### 设备驱动程序

+ 厂家提供设备驱动程序，方便操作系统进行控制。（不然设备之间的差异性太大了）
+ **直接和硬件打交道**，每个设备有一个

### 中断处理程序

+ **直接和硬件打交道**

见前面

## 缓冲区管理

硬件作为缓冲区的成本高。内存也能作为缓冲区。

### 缓冲区的作用

+ 缓和CPU和IO之间速度不匹配的矛盾。

+ 减少CPU的中断率，放宽对CPU的中断相应时间的限制。
  + 等缓冲区满了或者空了才产生中断，而不需要频繁打断。
+ 解决数据粒度不匹配的问题。
  + 输入输出进程每次可以产生一块数据，而设备每次只能输出一个字符
+ 提高CPU和IO之间的并行性。

### 单缓冲 双缓冲

**当缓冲区非空时，不能往缓冲区中冲入数据**，只能把缓冲区的数据传出。当缓冲区为空时，可以冲入数据，**但只有充满后才能取出**。（原理很重要，这种题目分析比较靠谱）

**管道通信中的管道就是缓冲区。想双向传输就必须设置两个管道。**

### 循环缓冲区

多个**大小相等**的缓冲区链接成一个**循环队列**

设置两个指针。in指向下一个可以冲入数据的缓冲区，out指向下一个可以取出数据的缓冲区。

### 缓冲池

包括三个队列：

空缓冲队列（空）

输入队列（输入满了装到这个队列后面）

输出队列（已经满了，从这个了里面取出一个）

## SPOOLing技术

为什么称为脱机技术？--脱离主机的控制进行输入输出操作

可以通过一个外围控制机来实现速度不匹配的问题。

外围控制机的作用：将纸带的数据转化为磁带的数据

### 假脱机技术--输入井和输出井

在**磁盘**上开辟两个存储区域。输入井和输出井。

**输入井**模拟脱机时输入的磁带

**输出井**模拟脱机是输出的磁带

**输入进程**模拟脱机输入时的外围控制机

**输出进程**模拟脱机输出时的外围控制机

#### 假脱机技术的原理：

在输入设备的控制下，“输入缓冲区“用于暂存从输入设备输入的数据，之后再转存到输入井中。

输出反之亦然

#### 打印机是一种独占式设备，如何实现共享呢？

+ 进程提出打印请求时，系统会**在输出井**中为其分配一个缓存区
+ 为其设置一个脱机文件，挂载输出进程后面

## 设备的分配与回收

### 设备分配时考虑的因素

+ 设备属性：
  + 独占性
  + 共享性

+ 算法：
  + FIFS

+ 安全性：
  + 安全分配方式（分配一个设备后就进行阻塞，完成后再唤醒，cpu和IO串行工作，但不会死锁）
  + 不安全分配方式（分配设备，进行不阻塞，并行工作，会死锁）

### 设备分配管理中的数据结构

+ 一个通道可以控制多个设备控制器，一个控制器可以控制多个设备
+ 每个设备都有一张DCT设备控制表
+ 每个控制器也有一张COCT控制器控制表
+ 每个通道都有一张CHCT通道控制表
+ SDT系统设备表。**系统中全部设备的情况。**

### 设备分配的步骤



## 磁盘的结构

磁道：一个个同心圆（多个磁道形成一个柱面）

扇区：每个磁道被划分为一个个扇区。最内侧数据越密集

柱面：多个盘面垂直排列

可以用**（柱面号，盘面号，扇区号）**来定位任意磁盘块

## 磁盘调度算法

**r是转速，转一圈的时间=1/r**

### FCFS

略

### SSTF（最短寻找时间优先）

优先处理的磁道是与当前磁头最近的磁道。

有可能会产生饥饿现象。

未必能保证总的时间对端=短。

### SCAN（电梯算法）

**磁头移动到最外侧的时候才能改变方向**

不会产生饥饿现象

### Look调度算法

如果在磁头移动方向上已经没有别的请求了，可以立即改变磁头移动方向。

### C-SCAN（电梯算法）

为了解决各个磁道相应不平均。返回时直接移动到起始端。

### C-Look算法



## 减少磁盘延迟时间的办法

问题背景：磁头读取一块内容，需要花一段时间处理。但是磁盘又在不断转动。

### 交替编号

解决办法：逻辑上相邻的扇区在**物理上有一定的间隔**

### 磁盘地址结构设计

**（柱面号，盘面号，扇区号）**

（盘面号，柱面号，扇区号）

采用第一种方法，在读取连续的磁盘块时，能减少磁头移动所消耗的时间。

### 错位命名

片面的编号错开。

本质上在于不能做到多个盘面同时读取。

## 磁盘管理

### 磁盘初始化

1. 划分扇区
2. 磁盘分区（CDE...）
3. 逻辑格式化，创建文件系统。

### 磁盘的引导块

开机时进行初始化工作。由初始化程序（存放在C盘中）完成。

从rom中读取自举装入程序进行初始化的工作。

自举装入程序加载初始化程序。

### 坏块的管理

在FAT表上标注。

磁盘控制器维护一些坏块的链表。