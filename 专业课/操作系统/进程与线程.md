[TOC]



# 进程与线程

## 背景知识

+ 每次新建一个进程都会给它分配一个PID、UID
+ PCB是进程控制块。用于管理进程，存放进程的信息。操作系统创建

+ 一个进程的实体由**PCB、程序段、数据段**组成。进程是动态的，进程实体（进程映像）是静态的。

## 进程

进程能独立运行、独立获得资源、独立接收调度的基本单位

## 进程的状态与转换

+ **不能直接由等待态直接转换为运行态，也不能由就绪态直接转换为等待态。**（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）

![image-20220904144616999](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220904144616999.png)

| 状态   | CPU  | 其他所需资源 |
| ------ | ---- | ------------ |
| 运行态 | √    | √            |
| 就绪态 | ×    | √            |
| 等待态 | ×    | ×            |

## 进程控制

+ 对系统中的进程进行管理。（状态转换）

+ **进程控制使用原语来实现**。（那么为什么需要原语来实现呢？为什么状态转换的过程要一气呵成呢？）
  + 如果不是的话会出现的这样的情况。进程A的状态标识符已经改变了，正准备从等待队列里移除，加入到运行队列中时，发生了中断。
  + 原语由关中断和开中断实现
    + 关中断之后就不再例行检查中断信号。
    + 只能由内核使用

### 进程的创建



### 进程的终止





### 补充

+ 作业是指还在**外存**里面没有投入运行的程序

+ PC 程序计数器，存放下一条指令的地址

+ IR 指令寄存器，存放当前正在执行的指令

计算机中这些资源是有限的，所以进程之间会争夺这些资源。另一个进程覆盖这些寄存器的内容。所以为了保护现场，**就将这些环境信息存放到PCB中**。这样就可以切换进程了。

## 进程通信

+ 进程之间的信息交换

+ 一个进程不能直接访问另一个进程的地址空间

### 共享存储

操作系统创建一个共享空间。两个进程的访问必须是**互斥**的。

有**基于数据结构的共享**和**基于存储区的共享**

### 消息传递

消息头+消息体

直接通信

间接通信（中间体信箱）

### 管道通信

管道只能采用半双工通信。没法设置双向通信。想实现得两个管道。

进程1往管道中写数据，当管道被写满了之后，进程2才能读数据。当管道中的数据全被读出来之后，才能再写数据。

+ 写满时不能再写，读空时不能再读。
+ 没写满不能读。没读空不能写。

## 线程和多线程模型

### 线程的概念

+ 线程是程序执行的最小单位

+ 可以理解为轻量级的进程
+ 引入线程之后，进程只作为除CPU之外的**系统资源的分配单位**(打印机这种)，不再是调度的基本单位。

### 线程的实现方式

#### 内核级线程

运行机会的载体

操作系统视角看到的线程，由操作系统实现。**内核级线程才是处理机分配的单位。**

#### 用户级线程

可以理解为是代码逻辑的载体

从用户视角能看到的线程，有线程库实现

### 多线程模型

#### 一对一

+ 开销大
+ 并发能力强

#### 多对一

+ 多个用户级线程映射到一个内核级线程
+ 线程管理开销小效率高
+ 一个被阻塞会使整个进程被阻塞

#### 多对多

取两者之所长

# CPU调度与上下文换

## 调度的概念

### 基本概念

作业就是一个具体的任务

用户向系统提交一个作业=用户让操作系统启动一个程序（来处理一个具体的任务）

### 三个层次

高级调度

中级调度

低级调度

![image-20220904161744022](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220904161744022.png)

**挂起态只是把进程放到外存中去了**

挂起和阻塞的区别：

两种状态都是暂时不能获得CPU服务。**但是挂起态是将进程映像调到外存中去了，而阻塞态下进程映像还在内存当中。**

|                          | 要做什么                   | 调度发生在             | 发生频率 |
| ------------------------ | -------------------------- | ---------------------- | -------- |
| 高级调度（**作业调度**） | 选择作业加入内存，创建进程 | 内外存之间（面向作业） | 低       |
| 中级调度（**内存调度**） | 调入或调出内存             | 内外存之间（面向进程） | 中       |
| 低级调度（**作业调度**） | 选择一个进程进行处理       | 内存和CPU              | 高       |

## 调度的实现

### 调度的时机

主动放弃

+ 主动请求阻塞
+ 发生异常
+ 正常结束

被动放弃

+ 时间片用完了
+ 更紧急的要处理
+ 优先级更高的进来

#### 不能进行进程切换

+ 处理中断的过程中
+ **进程在操作系统内核程序临界区**
  + 解释见前面
  + **如果是在一个普通的临界区中，是可以进行进程调度的。**比如说占有打印机这件事情
+ 原子操作的过程中

### 进程调度的方式

进程调度和切换是有代价的

#### 非剥夺式，非抢占式

适用于批处理操作系统

#### 剥夺式，抢占式

适用于分式操作系统和实时操作系统

## 调度算法

算法思想

算法规则

用于作业调度还是进程调度

抢占式还是非抢占式

优缺点

是否会导致饥饿

### 调度算法的评价指标

#### 资源利用率

**CPU利用率= CPU有效工作时间/CPU总的运行时间**

CPU总的运行时间=CPU有效工作时间+ CPU空闲等待时间

#### 吞吐率

**单位时间内 CPU 处理作业的个数**

总共完成了多少道作业/总共花了多少时间

#### 周转时间

**批 处 理 用 户 从 向 系 统 提 交 作 业 开 始 到 作 业 完 成 为 止 的 时 间 间 隔**

一个作业的周转时间等于=在外存等待的时间+在内存等待的使劲+执行的时间+等待IO的时间（阻塞的时间）

**周转时间：**完成时间-到达时间

**平均周转时间**：所有作业花费的时间/所有的作业数

花费的总时间包括等待的时间

**带权周转时间：**作业周转时间/作业实际运行时间=（作业完成时间-作业提交时间）/作业实际运行时间

#### **等待时间**

进程被建立后等待被服务的时间

#### 响应比

（等待时间+要求服务的时间）/要求服务的时间

### 先来先服务（FIFS）

+ 用于作业调度时，考虑哪个作业先到达后备队列（存在在外存中）；用于进程调度时，考虑哪个进程先到达就绪队列。

+ 是非抢占式的
+ 对长作业有利，对短作业不利。
+ 不会导致饥饿

### 短作业优先（SJF）

+ 最短的作业/进程优先得到服务（所谓最短就是要求服务的时间最短）
+ 每次**调度的时候**，**选择当前已经到达**的**运行时间最短**的作业
+ **在所有进程同时可运行时，SJF调度算法的平均等待时间、平均周转时间最少。**
+ 对于长作业是不利的。
+ 会导致饥饿

#### 抢占式短作业优先（SRTN）/最短剩余时间优先算法

+ 每当有进程加入就绪队列时就需要调度，如果**新到达的进程的剩余时间比当前运行的进程的剩余时间要短，就抢占处理机**。当前的变成就绪。

### 高相应比优先算法（HRRN）

+ 调度时计算各个作业的响应比，选择响应比最高的为其服务。不存在抢占式的情况。**只有当前一个作业主动放弃CPU时，才能进行调度**。
+ 避免了短作业优先的饥饿问题

# 同步与互斥

# 死锁