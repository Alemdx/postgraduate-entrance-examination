[TOC]



# 进程与线程

## 背景知识

+ 每次新建一个进程都会给它分配一个PID、UID
+ PCB是进程控制块。用于管理进程，存放进程的信息。操作系统创建

+ 一个进程的实体由**PCB、程序段、数据段**组成。进程是动态的，进程实体（进程映像）是静态的。

## 进程

进程能独立运行、独立获得资源、独立接收调度的基本单位

+ 引入进程的目的是**更好的使多道程序并发执行**
  + 可以理解 最开始是顺序执行的，要想并发执行就引入了进程

## 进程的状态与转换

+ **不能直接由等待态直接转换为运行态，也不能由就绪态直接转换为等待态。**（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）

![image-20220904144616999](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220904144616999.png)

| 状态   | CPU  | 其他所需资源 |
| ------ | ---- | ------------ |
| 运行态 | √    | √            |
| 就绪态 | ×    | √            |
| 等待态 | ×    | ×            |

### 可能导致阻塞的因素

请求资源：申请临界区资源、读磁盘、进行IO

## 进程控制

+ 对系统中的进程进行管理。（状态转换）

+ **进程控制使用原语来实现**。（那么为什么需要原语来实现呢？为什么状态转换的过程要一气呵成呢？）
  + 如果不是的话会出现的这样的情况。进程A的状态标识符已经改变了，正准备从等待队列里移除，加入到运行队列中时，发生了中断。
  + 原语由关中断和开中断实现
    + 关中断之后就不再例行检查中断信号。
    + 只能由内核使用

### 进程的创建



### 进程的终止





### 补充

+ 作业是指还在**外存**里面没有投入运行的**程序**
  + 进程已经在内存中了

+ PC 程序计数器，存放下一条指令的地址

+ IR 指令寄存器，存放当前正在执行的指令

计算机中这些资源是有限的，所以进程之间会争夺这些资源。另一个进程覆盖这些寄存器的内容。所以为了保护现场，**就将这些环境信息存放到PCB中**。这样就可以切换进程了。

## 进程通信

+ 进程之间的信息交换

+ 一个进程不能直接访问另一个进程的地址空间

### 共享存储

操作系统创建一个共享空间。两个进程的访问必须是**互斥**的。

有**基于数据结构的共享**和**基于存储区的共享**

### 消息传递

消息头+消息体

直接通信

间接通信（中间体信箱）

### 管道通信

**管道只能采用半双工通信。没法设置双向通信**。想实现得两个管道。

进程1往管道中写数据，当管道被写满了之后，进程2才能读数据。当管道中的数据全被读出来之后，才能再写数据。

+ 写满时不能再写，读空时不能再读。
+ **没写满不能读。没读空不能写。**
+ 读没了不能再读，写没了不能再写。为了避免这种情况的出现，对其他的读写操作进行阻塞。

## 线程和多线程模型

### 注意点

线程共享进程内的全部资源。

线程不能直接访问同一个进程内的其他线程。（同级之间不能直接访问）但是可以像进程一样，通过管道，信息等方式进行访问

### 线程的概念

+ 线程是程序执行的最小单位
+ 可以理解为轻量级的进程
+ 引入线程之后，进程只作为除CPU之外的**系统资源的分配单位**(打印机这种)，不再是调度的基本单位。
+ 引入进程的目的是**减小程序在并发执行时所付出的时空开销**，提高并发性能

### 线程的实现方式

#### 内核级线程

+ 操作系统视角看到的线程，由操作系统实现。**内核级线程才是处理机分配的单位。**

+ 系统开销变大，需要从用户态切换到内核态

#### 用户级线程

+ 可以理解为是代码逻辑的载体

+ 从用户视角能看到的线程，有线程库实现

+ **进程的管理都是由应用程序实现，内核意识不到线程的存在。进程可以设置自己的调度算法。可以不要切换到内核。（优点）**
+ **一个被阻塞，该进程内所有的线程都被阻塞。不能发挥多核的优势。（缺点）**

### 多线程模型(是指用户级线程和内核级线程之间的关系)

#### 一对一

+ 开销大
+ 并发能力强

#### 多对一

+ **多个用户级线程映射到一个内核级线程**
+ 线程管理开销小效率高
+ 一个被阻塞会使整个进程被阻塞

#### 多对多

取两者之所长

# CPU调度与上下文换

## 调度的概念

### 基本概念

作业就是一个具体的任务

用户向系统提交一个作业=用户让操作系统启动一个程序（来处理一个具体的任务）

### 三个层次

高级调度

中级调度

低级调度

![image-20220904161744022](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220904161744022.png)

**挂起态只是把进程放到外存中去了**

挂起和阻塞的区别：

两种状态都是暂时不能获得CPU服务。**但是挂起态是将进程映像调到外存中去了，而阻塞态下进程映像还在内存当中。**

|                          | 要做什么                   | 调度发生在             | 发生频率 |
| ------------------------ | -------------------------- | ---------------------- | -------- |
| 高级调度（**作业调度**） | 选择作业加入内存，创建进程 | 内外存之间（面向作业） | 低       |
| 中级调度（**内存调度**） | 调入或调出内存             | 内外存之间（面向进程） | 中       |
| 低级调度（**进程调度**） | 选择一个进程进行处理       | 内存和CPU              | 高       |

## 调度的实现

### 调度的时机

主动放弃

+ 主动请求阻塞
+ 发生异常
+ 正常结束

被动放弃

+ 时间片用完了
+ 更紧急的要处理
+ 优先级更高的进来

#### 不能进行进程切换

+ 处理中断的过程中
+ **进程在操作系统内核程序临界区**
  + 解释见前面
  + **如果是在一个普通的临界区中，是可以进行进程调度的。**比如说占有打印机这件事情
+ 原子操作的过程中

### 进程调度的方式

进程调度和切换是有代价的

#### 非剥夺式，非抢占式

适用于批处理操作系统

#### 剥夺式，抢占式

适用于分式操作系统和实时操作系统

## 调度算法

算法思想

算法规则

用于作业调度还是进程调度

抢占式还是非抢占式

优缺点

是否会导致饥饿

无论是响应比还是周转时间都是大于1的。

### 调度算法的评价指标

#### 资源利用率

**CPU利用率= CPU有效工作时间/CPU总的运行时间**

CPU总的运行时间=CPU有效工作时间+ CPU空闲等待时间

#### 吞吐率

**单位时间内 CPU 处理作业的个数**

总共完成了多少道作业/总共花了多少时间

#### 周转时间

**千万注意区分平均周转时间和带权周转时间。**

**批 处 理 用 户 从 向 系 统 提 交 作 业 开 始 到 作 业 完 成 为 止 的 时 间 间 隔**

一个作业的周转时间等于=在外存等待的时间+在内存等待的使劲+执行的时间+等待IO的时间（阻塞的时间）

**周转时间：**完成时间-到达时间

**平均周转时间**：所有作业花费的时间/所有的作业数

花费的总时间包括等待的时间（就是所有时间）

**每个的周转时间相加**

**带权周转时间：**作业周转时间/作业实际运行时间=（作业完成时间-作业提交时间）/作业实际运行时间

#### **等待时间**

进程被建立后等待被服务的时间

#### 响应比

（等待时间+要求服务的时间）/要求服务的时间

### 先来先服务（FIFS）

+ 用于作业调度时，考虑哪个作业先到达后备队列（存在在外存中）；用于进程调度时，考虑哪个进程先到达就绪队列。

+ 是非抢占式的
+ 对长作业有利，对短作业不利。
+ 不会导致饥饿

### 短作业优先（SJF）

+ 最短的作业/进程优先得到服务（所谓最短就是要求服务的时间最短）
+ 每次**调度的时候**，**选择当前已经到达**的**运行时间最短**的作业
+ **在所有进程同时可运行时，SJF调度算法的平均等待时间、平均周转时间最少。**
+ 对于长作业是不利的。
+ 会导致饥饿

#### 抢占式短作业优先（SRTN）/最短剩余时间优先算法

+ 每当有进程加入就绪队列时就需要调度，如果**新到达的进程的剩余时间比当前运行的进程的剩余时间要短，就抢占处理机**。当前的变成就绪。

### 高相应比优先算法（HRRN）

+ 调度时计算各个作业的响应比，选择响应比最高的为其服务。不存在抢占式的情况。**只有当前一个作业主动放弃CPU时，才能进行调度**。
+ 避免了短作业优先的饥饿问题

### 时间片轮转算法

+ 是一种抢占式的算法。不抢占式的指自己主动放弃。

+ 维护一个队列。按照到达的先后顺序加入队尾。

+ **如果时间片大于作业剩余运行时间，会主动进行放弃。重新进行调度。**

+ 如果时间片**太大**，时间片轮转调度就会**变为先来先服务算法**。
+ 不会导致饥饿

### 优先级调度算法

操作系统更偏好于IO型进程（IO繁忙型进程）。因为IO和CPU可以并行工作，这样可以让IO设备尽早的投入到工作

#### 抢占式

立即抢占。不要搞错。这里压根就不存在时间片。

#### 非抢占式

主动放弃时进行调度。

队列中找出优先级最高的

### 多级反馈队列

是对其余的算法的折中权衡

#### 算法描述

+ 设置多个队列，优先级从小到大。（但是优先级高的分配到的时间片是少的）
+ 当一个时间片用完时，该任务还没有结束，则进入下一个低优先级的队列的队尾

+ 当有一个更高优先级的进程来到时，**立即发生抢占（不用等待之前的进程时间片用完）。被抢占的进程加到原来队列的队尾。**

## 临界区

> 临界区是进程访问临界资源的那段代码。按照我的理解，临界资源有很多种，所以一个进程有可能会有很多个临界区，分别用来访问不同的临界资源。
> 这些临界区中，有的是用来访问操作系统内核中的数据结构或数据的，比如系统时钟（猜的），等等，叫做内核程序临界区。
> 进程访问临界资源时，临界区会上锁，然后其他进程临界区就不能访问同一个临界资源了。然而内核临界资源很重要！不可以长时间被同一个进程占用，所以访问内核临界资源时，不可以进行进程切换，等到进程退出临界区后才可以。
> 普通临界资源就是像普通I/O设备什么的，比如，打印机，进程访问这些资源的时候，很慢，会自动阻塞，等待资源使用完成。

+ 临界区分为两个部分：**普通资源临界区**和**内核临界区**
+ 在内核临界区不能进行进程调度和切换，在普通临界区中可以。
  + 内核临界区中使用了关中断。就没法进行进程调度了。（进程调度是中断驱动的）



