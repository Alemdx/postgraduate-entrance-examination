[TOC]

# 内存的基础知识

## 内存

内存是用来存放数据。程序执行前**需要先放到内存中才能被CPU处理**。

一个B(Byte)=8b(bit)

## 指令的工作原理

### 程序段（代码段）

代码段是**只读**的。（可以理解为二进制可执行文件）

把程序转换为指令（二进制的形式），存放在程序段中

### 数据段

用于存放数据的地方，例如存放一些变量

## 三种装入方式

装入是指把程序装入到内存之中。指令（程序编译之后）有时候会用到内存中的地址，这些地址往往是逻辑地址

### 绝对装入

编译链接后得到的装入模块的指令直接就使用了绝对地址（物理地址）。

+ 比如说把某个数据放到内存中179的位置。在这个电脑里面可以执行，但是另一个电脑179的位置已经有东西存在了。

### 静态重定位

可重定位装入。使用的是相对地址。

更具程序的初始地址+偏移地址得出。（这个地址就固定了）

+ 要求在一个作业装入内存时，必须**分配其要求的全部内存空间**。（一次全部装入）
+ 作业一旦进入内存后，**在运行期间就不能再移动。**

### 动态重定位

动态运行时装入。

+ 并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行是才进行。
+ **需要一个重定位寄存器**
  + 存放装入模块存放的起始位置
  + 允许程序在内存中发生移动

## 从写程序到程序运行

源代码**编译**成目标模块，目标模块**链接**成装入模块装入内存。

+ 链接分为
  + 静态链接
  + 装入时动态链接
  + 运行时动态链接

# 内存管理的概念

## 操作系统应该实现的功能

+ 操作系统负责**内存空间的分配与回收**
+ 从逻辑上实现对**内存空间的扩充**
+ 实现地址**转换方法**
+ **内存保护**
  + 设置一对上下限寄存器，存放进程的上下限地址
  + 采用重定位寄存器（存放起始地址）和界地址寄存器（存放进程的最大逻辑地址）进行越界检查

## 内存空间的分配与回收

外部碎片：随着时间的推移，内存中会产生越来越多小的内存块，内存的利用率也会随之下降。这些小的内存块称为外部碎片。外部碎片可以通过**紧凑技术**来解决。

内部碎片：程序小于**固定分区大小**时。也要占用一个完整的内存分区，这样分区的内部空间就存在空间浪费

区分内部碎片和外部碎片的最好方法是看分区是不是固定的？

### 连续分配管理方式

连续分配，系统为用户分配的必须是**连续的内存空间**

#### 单一连续分配

内存中只存放一道程序

+ 无外部碎片有内部碎片（整个内存就相当于一个固定分区？）

#### 固定分区分配

提前为内存划分号分区

+ 无外部碎片有内部碎片

#### 动态分区分配

在装入内存时，根据进程实际需要，动态的为进程分配内存

+ 无内部碎片有外部碎片

### 内存回收的四种情况

相邻空闲分区需要合并

## 动态分区分配算法

### 首次适应算法

空闲分区以**地址递增**次序排列，找到**第一个满足**的空闲分区。然后修改该分区。

### 临近适应算法

在首次适应算法的基础上，每次都**从上次查找结束的位置开始检索**

+ **算法的开销比较小**
+ 会使高地址的大分区也被用完

### 最佳适应算法

空闲分区以**容量递增**次序排列，找到**第一个满足**的空闲分区。然后修改该分区。**进行重新排序。**

+ 产生最多的外部碎片
+ 算法开销大

### 最坏适应算法

空闲分区以**容量递减**次序排列，找到**第一个满足**的空闲分区。然后修改该分区。**进行重新排序。**

+ 算法开销大

# 分页存储管理（重要）

+ 是非连续的存储方式

+ 分页管理不会产生外部碎片，因为是固定分区划分的
+ 只有最后一个块才会产生碎片



### 针对于物理空间而言（页框）

将内存空间分为大小相等的分区，每个分区就是一个**“页框“**。

页框=页帧=内存块=物理块=物理页面

每个页框都有一个编号，即“**页框号**“，页框号从0开始。

页框号=页帧号=内存块号=物理块号=物理页面号

### 针对与进程的逻辑空间地址（页面）

将进程的逻辑地址分为与**页框大小相等的部分**，每个部分称为一个**页**或者**页面**。每个页面也有一个编号，称为**页号**

进程的页面与内存的页框一一对应

### 重要数据结构（页表）

页表项分为页号和物理块号。但页号常常是省略的。

**页表长度**是指页表中共有多少个页表项，即总共有多少个页，**页表项长度**是指这个页表项占多大存储空间（换句话说就是页表项有多少位）。

+ 页表项在内存中是连续存放的

+ **建立页号与块号之间的映射关系**。保存在PCB中。
+ 注意页号从0开始计算

#### 问题一：每个页表项占多少个字节？

- 由计算机中内存块的数量推算出页表项中块号占多少个字节。（**内存块的数量就是块号的范围**，由范围推算出长度）
- 第I号页表项的存放地址=基址+X*I（参考数组中元素的查找，基址+偏移）
- 由于页号的隐含的（连续存储，和数组的下标一样）。如果每个页表项占XB，则存储整个页表需要X*（n+1）B

+ **注意页表记录的只是内存块号，而不是内存块的起始地址。J号内存块的起始地址=J*内存块大小。**（一般内存块大小和页面大小是一样的）

#### 问题二：如何实现地址的转换

页面是离散存放的，页面的内部是连续存放的。

如何访问逻辑地址A？

1. 确定逻辑地址A对应的页号P

2. P页号在内存中的起始地址（查页表）

3. 确定逻辑地址A的“页内偏移量”W

   **逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W**

4. 如果每个页面的大小为$2^k$B,用二进制数表示逻辑地址，**则末尾K位即为页内偏移量**，**其余部分就是页号**
5. 有页面大小可以得出页面偏移量的位数，从而可以确定逻辑地址的结构。（逻辑地址由K位的页内偏移量和M位的页号组成）

### 基本地址转换机构

用于实现逻辑地址转换为内存中的物理地址

PCB中存放了页表寄存器和PC。

+ 页表寄存器包含了页表始址F和页表长度M
+ PC指向下一条指令的逻辑地址A

如何根据逻辑地址A找出物理地址呢？

1. 根据逻辑地址计算出页号、页内偏移量
2. 判断页号是否越界
3. 查询页表，找到页号对应的页表项，确定页面存放的内存块号

### 具有快表的地址变换机构

快表又称联想寄存器（TLB），是一种访问速度比内存快很多的**高速缓存**（存放最近被频繁访问的）。页表是慢表

+ 判断是否越界
+ 判断快表是否命中
  + 不命中则访问慢表，将该项加入快表。（查询慢表也是访问内存）

### 两级页表

当页表很大的时候，采用两级页表

缺页中断属于**内中断**

#### 采用多级页表时，各级页表的大小不能超过一个页面

按字节编址？一个地址对应的是一个字节

如果页面的大小为4KB，每个页表项的大小为4K，那么每页最多能存放1K个页表项。假如页表项总共有2^28个，那么就需要建立至少三级页表。

#### N级页表需要访问N+1次访存

# 基本分段存储管理

为什么是二维的？

按程序**自身的逻辑**关系**划分为若干个段**

段表：实现各个**逻辑段**到**实际物理内存位置**的映射关系

+ 段号+段长+基址
+ 各段表项的长度是相同的

### 如何实现逻辑地址到物理地址的转换？

1. 根据逻辑地址得到段号和段内地址
2. 判断段号是否越界，若越界则中断，否则就直接执行
3. 查询段表，由段号得到基址（物理）
4. **检查段内地址是否超过段长**（这个是分页式没有的）
5. 物理地址=段基址+段内地址

### 分段和分页的区别？

+ 分段的地址空间是二维的，分页的地址空间是一维的
+ 分段比分页更容易实现**信息的共享和保护**
  + 纯代码或可重入代码（不属于临界资源）可以被共享访问。
  + 因为分页不是按照功能来划分的，每一页中并不是所有都能进行共享。

# 段页式管理方式

**每个进程有一张段表，每个分段有一张页表**

**段表表项中至少包含段号，页表长度和页表起始地址**

**每个页表表项中包含页号和块号**

+ 分页分段的优缺点分析

|          | 优点                                               | 缺点                                                         |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 分页管理 | 内存利用率高，不会产生外部碎片，会产生**内部碎片** | 不方便按照逻辑实现信息的共享和保护                           |
| 分段管理 | 方便按照逻辑实现信息的共享和保护                   | 如果段长过大，为其分配很大的连续空间会很不方便。会产生**外部碎片** |

## 段页式管理的逻辑地址结构

段号+页号+页内偏移量

**逻辑地址需要访问三次内存**
