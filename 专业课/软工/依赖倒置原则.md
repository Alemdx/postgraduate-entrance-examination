# 依赖倒置原则

程序要依赖于抽象接口，不要依赖于具体实现。

## 什么叫做依赖与具体实现？

```java
//本田汽车的创建
public class HondaCar{
    public void Run(){
        Console.WriteLine("本田开始启动了");
    }
    public void Turn(){
        Console.WriteLine("本田开始转弯了");
    }
    public void Stop(){
        Console.WriteLine("本田开始停车了");
    }
}
//福特汽车的创建
public class FordCar{
    public void Run(){
        Console.WriteLine("福特开始启动了");
    }
    public void Turn(){
        Console.WriteLine("福特开始转弯了");
    }
    public void Stop(){
        Console.WriteLine("福特开始停车了");
    }
}

//自动驾驶类
public class AutoSystem{
    public enum CarType{
        Ford,Honda
    };
    private HondaCar hcar=new HondaCar();
    private FordCar fcar=new FordCar();
    //这里我们可以看到该类依赖于不同类型的车，即我每创建一种车，都需要对该类进行较大的修改。全部new一个
    private CarType type;
    public AutoSystem(CarType type){
        this.type=type;
    }
    public void RunCar(){
        if(type==CarType.Ford){
            fcar.Run();
        } else {
            hcar.Run();
        }
    }
    public void TurnCar(){
        if(type==CarType.Ford){
            fcar.Turn();
        } else { 
            hcar.Turn();
        }
    }
    public void StopCar(){
        if(type==CarType.Ford){
            fcar.Stop();
            } else {
                hcar.Stop();
            }
    }
}
```

## 什么叫做依赖于接口编程？

```java
//先定义接口
public interface ICar
{
void Run();
void Turn();
void Stop();
}
//对接口的实现1
public class BmwCar:ICar
{
public void Run()
{
Console.WriteLine("宝马开始启动了");
}
public void Turn()
{
Console.WriteLine("宝马开始转弯了");
}
public void Stop()
{
Console.WriteLine("宝马开始停车了");
}
//对接口的实现2
public class FordCar:ICar
{
publicvoidRun()
{
Console.WriteLine("福特开始启动了");
}
public void Turn()
{
Console.WriteLine("福特开始转弯了");
}
public void Stop()
{
Console.WriteLine("福特开始停车了");
}
}
//通过构造函数进行传递    
public class AutoSystem
{
private ICar icar;//这是最大的差别。这里是接口而不是一个对象
public AutoSystem(ICar icar)
{
this.icar=icar;
}
private void RunCar()
{
icar.Run();
}
private void TurnCar()
{
icar.Turn();
}
private void StopCar()
{
icar.Stop();
}
}
```



工厂模式相比于DIP就是多了一个选择功能呗！

# 工厂模式

+ 我们可以看到，工厂模式也是面向接口编程

```java
//定义接口
public interface Shape {
   void draw();
}

//接口的实现1
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
//接口的实现2
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
//这里显示的工厂的内部逻辑
//工厂模式一定是返回一个对象吗？所以工厂的作用是为了返回所需的对象？
public class ShapeFactory { 
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```



## 问题

依赖和组合聚合之间的区别是什么？