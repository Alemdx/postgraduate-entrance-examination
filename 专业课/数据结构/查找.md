# 查找

[TOC]

## 查找的基本概念

平均查找长度（ASL）

+ 查找成功
+ 查找失败
  + 考虑指针最终可能停留在哪些地方。构造出空节点。

## 顺序查找

无论怎么优化，时间复杂度都是$O(n)$

进行排序优化后，其实相当于构造了一棵二叉树。但该树不是完全二叉树。树高是n

## 折半查找

时间复杂度$log(n)$

（二分查找）

不可能基于链表实现

### 折半查找树的构造

+ 一定是一个**平衡二叉树**，只有最下面一层是不满的。树高为$[log(n+1)]$

+ 如果当前low和high之间有奇数个元素，则mid分隔后，**左右两个部分元素个数相等**
+ 如果当前low和high之间有偶数个元素，则mid分隔后，**左半部分比右半部分少一个元素**
+ 折半查找的判定树中，若$mid=[(low+high)/2]$,则对于任何一个结点，必有：**右子树-左子树=0或1**
+ **有n个成功结点，有n+1个失败结点**。（等于成功节点的空链域的数量）

## 分块查找

特点：块内无序、块间有序

若索引表中不包含目标关键字，则折半查找索引表最终停靠在**low>high**，要**在low所指分块中查找**

$s=\sqrt n$   ASL最小

## 树型查找

### 二叉排序树（BST）

+ ASL=$O(logn)$
  + 很大程度上取决于树的高度是多少
  + **因此引入二叉平衡树**。这样查找效率更高
  + 是排序的，但不一定是平衡的

非递归空间复杂度为$O(1)$

递归实现，空间复杂度是$O(h)$

+ 二分查找的判定树是唯一的（因为排好序了，每次都是从中间先生成），而二叉排序树的查找不唯一。相同的关键字其插入顺序不同可能生成不同的二叉排序树。（没有排好序）

### 平衡二叉树（AVL树）

#### 平衡二叉树的插入（删除）

+ 从插入结点往回找到第一个不平衡结点，调整以该结点为根的子树。

+ 每次调整的对象都是最小的不平衡子树。

目标：

+ 恢复平衡
+ 保持二叉排序树特性

调整最小不平衡子树（方便记忆）：（联想大二时用的方法，抽象出三个点）

+ 只有左孩子才能右上旋
+ 只有右孩子才能左上旋

#### 平衡二叉树的查找

+ **可以用于求二叉平衡树的最多比较次数。**
  + 因为对多比较次数意味着树要最高，但是树的高度收到平衡这个约束条件

+ 深度为h的平衡树中含有最少的**结点数**：
  + 递推公式$n_h=n_{h-1}+n_{h-2}+1$
+ 含有n个结点的平衡二叉树的最大深度为$log_2n$



### 红黑树

### B树(本质上就是区间的划分)

#### 基本概念

+ B树的叶结点是外部结点。相当于二叉树中判断失败的结点

+ **结点孩子的个数等于结点中关键字个数加1。**
+ 同一结点中，关键字是递增的。

+ 叶节点表示查询失败的位置。

#### B树的高度

#### B树的插入

+ 每次一定是插入到最底层的中断结点当中
+ 如果结点关键字个数超过上限则进行分裂。从中间位置$[m/2]$将关键字分为两个部分。**将关键字提到父节点当中。**

#### B树的删除

如果删除后关键字没有低于下限：

+ 若被删除的关键字在**终端结点**，则直接删除该关键字
+ 若被删除的关键字在**非终结结点**，则用直接前驱或直接后继来代替被删除的关键字
  + 直接前驱：当前关键字左侧指针所指子树中最右下的元素
  + 直接后继：当前关键字右侧指针所指子树中最左下的元素

删除后关键字低于下限：

+ 兄弟够借（判断哪边的兄弟够借）
  + 用当前结点的后继、后继的后继来添补空缺。（注意不能直接移过去。要调整父节点）
  + 用当前结点的前驱、前驱的前驱来添补空缺。（注意不能直接移过去。要调整父节点）

+ 兄弟不够借
  + 将父亲结点拉下来，将两个兄弟结点合并。**注意判断父亲结点拉下来后，父亲节点中的关键字是否满足要求。**

### B+树

类似于分块查找

#### 特点

+ 非叶根结点至少有两棵子树(本质上是为了追求平衡)
+ **结点的子树的个数与关键字个数相等**
+ 所有的**叶子节点包含全部关键字**
+ 支持顺序查找
+ **注意关键字表示的是右区间的取值**
+ 在B+树中，无论查找成功与否，最终一定都要走到最下面的结点

|                      | B树(m阶)                                                     | B+树（m阶）                                                  |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **关键字和子树**     | n个关键字，n+1（m）个子树                                    | n个关键字，n(m)个子树                                        |
| **关键字的下限**     | $[m/2]-1$(根节点除外,向上取整)                               | $[m/2]$（向上取整）                                          |
| **关键字上限**       | m-1                                                          | m                                                            |
| **关键字的出现**     | 各个结点中的关键字是不重复的                                 | 叶子结点包含全部关键字，非叶子结点中出现过的关键字也会出现在叶子结点中 |
| **信息**             | 结点中包含了关键字对应的记录的存储地址（每个关键字都带信息） | 叶子结点包含信息，非叶子结点仅起索引作用（只有叶子中带信息） |
| **子树的下限**       | m/2向上取整                                                  | m/2向上取整                                                  |
| **根结点子树的个数** | 最少1个                                                      | 最少两个                                                     |



