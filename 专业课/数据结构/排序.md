[TOC]

# 排序

## 基本概念

稳定性:**关键字相同的元素在排序之后的相对位置不变**

**很多的空间复杂度都是$O（1）$,因为并没有开辟新的数组。**

稳定的排序算法不一定比不稳定的更好

+ 内部排序

+ 外部排序
  + 存储在外存，需要考虑磁盘读写次数

## 插入排序O(n^2)

### 直接插入排序

思想：

+  将一个待排序的记录按其关键字大小插入到**已经排好序**的子序列中。
+ 在已排序好的子序列中查找

### 折半插入排序

+ 内层循环的顺序查找可以用折半查找进行优化（对子序列的查找）。
  + 为保证稳定性，在mid右边进行插入

### 希尔排序（不确定）

空间复杂度$O(1)$

将间隔为d的元素形成一个子表

+ 不稳定
  + 相同的元素不在同一个字表

## 交换排序

根据序列中两个关键字的比较结果来兑换这两个记录的位置

### 冒泡排序

思想：**每一趟让最小的数冒到前面**

需要区分交换次数和移动次数

冒泡排序是稳定的。

冒泡排序可以用于链表

### 快速排序

+ 将其转化为二叉树，二叉树的层数等于递归调用的深度

​		n个结点的二叉树，最小高度为$log_2n$向下取整加一

​		最大高度为n

+ 递归调用的深度决定了算法的时间复杂度和空间复杂度

​	**时间复杂度为$O(n*递归层数)$**

​	空间复杂度就是递归层数

+ 如果每一个选中的“枢轴”将待排序的排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高。
  + 平均的时间复杂度接近于最好的情况
  + 所有应用中最好的

+ 不稳定
+ 注意区分一次划分与一趟排序

## 选择排序

### 简单选择排序

注意：和直接插入排序的区别在于，直**接插入排序是向已排好的序列中插入，简单选择排序是在待排序的序列中选择**，换句话说就是一个操作的对象是前面，一个操作的对象是后面。

算法思想：每一趟在待排序元素中**选取关键字最小（或最大）的元素加入**有序子序列

算法是不稳定的

无论是什么序列，都需要进行n-1趟

### 堆排序

每一趟在待排序元素中选取关键字最小（或最大）的元素加入到有序序列

#### 什么是堆

小根堆：在**完全二叉树**中：根节点的值<=左右结点的值

大根堆：.... 根节点的值>=左右结的值

#### 算法思路

+ 建立大根堆
  + **从最后一个非叶节点开始调整**

+ **根据大根堆的特性，堆顶的元素总是最大的。我们将堆顶元素与数组最后一个元素进行互换。这样数组最大的值就在最后面，构成的新的数组是原数组的长度减一。然后堆新的数组进行堆排序，找出最大的值。**（这种排序是在大根堆的基础上）

#### 结论

一个结点，每下坠一层，最多只需要对比关键字两次

基于大根堆是升序，基于小根堆是降序

#### 算法效率分析

建堆的时间复杂度是$O(n)$

排序的时间复杂度是$O(log_2n)$

总的时间复杂度是$nlog_2n$

####  稳定性

堆排序是不稳定的



#### 堆的插入与删除

插入的时候放在最底层，然后逐步**向上冒泡**

删除的时候用最后一个元素来代替被删除的元素，然后进行**下坠的调整（**这里为什么不进行向上冒泡呢，因为这是一个已经满足堆要求的数组，向上比是没有意义的）



## 归并排序

归并：前提是两个或多个有序序列

### 归并排序

算法思想：两两合并

#### 算法效率分析

总共要归并$log_2n$次

每次的时间复杂度是n

总共的时间复杂度是$nlog_2n$

#### 稳定性

稳定

### 基数排序

#### 算法思想

依次比较个十百....各位。先按个位排，再按十位排，诸如此类