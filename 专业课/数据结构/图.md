# 图

[TOC]

## 图的定义

+ 图不可以是空图
+ 边集可以是空集，点集不能是空集

### 无向图

无向边（边）

### 有向图

有向边(弧)

**后面的是弧头，前面的是弧尾。**

### 简单图、多重图

### 顶点的度

#### 无向图

依附于该顶点的边的条数

**度数和=边数的两倍**

#### 有向图

入度和出度的**和**

所有顶点的入度之和=所有顶点的出度之和

### 顶点与顶点间关系的描述

#### 路径

顶点的序列

#### 回路

第一个顶点和最后一个顶点相同

#### 简单路径

路径中不存在重复的路径（对于无向图，感觉可以看是否有路径出现了两次）

#### 简单回路

除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路

#### 路径长度

路径上边的数目

#### 点到点的路径

两顶点之间的最短路径

#### 连通与不连通

+ 无向图中，有路径存在，就是连通的
+ 有向图中，有**来去**的路径，则这两个顶点是**强连通**的（注意这里是AB点之间可以相互到达，但是相互到达的意思并不意味着A可以直接到达B，B可以直接到达A，而是说也可以通过其他的点间接到达）
+ 若任意两个顶点之间都是连通的，则是**连通图**，反之不是
  + **若是连通，则至少有n-1条边**
  + **最多有$C_{n-1}^2$条边**
+ 若任意两个顶点之间都是强连通的，则称此图为强连通图（所以强连通图是在有向图中才有）
  + 若是强连通，最少有n条边。即形成一个回路

### 子图和生成子图

子图：点是原来的子集，边是原来的子集

生成子图：点的数量和原来相同，但是边的数量不一定和原来相同

### 连通分量（无向图）

**连通图可能是树，也可能是环。**

无向图中的**极大连通子图**称为**连通分量**

+ 举个例子。中国={大陆+香港+台湾}。不同联通分量之间是没有直接的边的

极大连通子图：子图必须连通，且包含尽可能多的顶点和边

### 强连通分量（有向图）

有向图中的极大强连通子图称为有向图的**强连通分量**

+ 这里需要注意，如果不能相互到达，则不再同一个连通分量之内

### 极大连通子图和极小连通子图

![image-20220730155011014](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220730155011014.png)

### 生成树

+ 连通图的生成树是**包含图中全部顶点的一个极小连通子图**
  + 注意这里一定包含n个顶点
  + 边的个数尽可能少，但要保持连通
  + 如果有n个顶点，则有n-1条边
  

### 生成森林

+ 非连通图中，连通分量的生成树构成了非连通的生成森林

### 边的权、带权图/网

带权路径长度：边的权值之和

## 图的存储结构

### 邻接矩阵

二维表

#### 无向图

遍历某一行或者某一列就能求出度

#### 有向图

出度：求行中非0

入度：求列中的非0

#### 邻接矩阵存储带权图

+ 不可达设置为无穷大
+ 其余的设置权值邻接表

#### 性能分析

+ 空间复杂度：$O(n^2)$

+ 可以使用对称矩阵的方式来存储（节省空间）

#### 邻接矩阵的性质

+ **设邻接矩阵为A,$A^n$的元素$A^n[i][j]$等于由顶点i到顶点j的长度为n的路径的数目**。
  + $A[i][j]=A[i][k]*A[k][j]$（如果可达，则为1）

### 邻接表法

+ 顺序存储+链式存储
+ 邻接表的表示方法是不唯一的。即在一个链表中，各个元素的位置是可以互换的
+ 但是在邻接矩阵时，表示方式是唯一的。

#### 性能分析

##### 无向图

+ 在无向图中，边的数据是有冗余的，因为一条边存储了两次

+ 整体的空间复杂度为$O(|V|+2|E|)$
+ 度的个数等于链表中元素的个数

##### 有向图

+ 有向图不会产生这种冗余的问题

+ 整体的空间复杂度为$O(|V|+|E|)$

+ 找出度很简单，但是找入度很麻烦了。只能一次遍历所有的链表

### 十字链表

+ 存储有向图
+ 解决邻接矩阵空间复杂度高的问题，解决邻接表找入度不方便的问题。

#### 十字链表的数据结构

**这里搞清楚弧头弧尾就能理解了。**（弧尾才是本结点）

定义两种结构体：顶点结点和弧结点。

顶点结点：

+ 存放了三个元素，数据域，该顶点作为**弧头**的第一个条弧，该顶点作为**弧尾**的第一条弧

弧结点：

+ 存放了五个元素：弧尾顶点编号、弧头顶点编号、权值、弧头相同的下一条弧、弧尾相同的下一条弧

**firstin一定是指向hlink，fristout一定是指向tlink。**这样的话其实就可以分开考虑了。

+ 十字链表的空间复杂度为$O(|V|+|E|)$

### 邻接多重表

+ 存储无向图

和十字链表差不多

+ 空间复杂度为$O(|V|+|E|)$

### 图的基本操作

一些操作的最低时间复杂度和最高时间复杂度

## 图的遍历

### 广度优先遍历

如果是**非连通图**，则**不能遍历完所有的结点**。

但是因为有一个visit数组，所以非连通的点都是没有被visit的。所以只要找到还没有被访问的结点就行了。

调用BFS的次数等于连通分支的数量

#### 树的广度优先遍历

层次遍历

#### 图的广度优先遍历

选择一个顶点，将其push进栈。将他pop出栈，将与它相邻的顶点push进去。直到栈为空结束。

#### 树的广度优先遍历VS图的广度优先遍历

相同：都要找到与它相邻的结点

不同：树不存在回路，图存在回路。解决回路的方法，当访问过该点时，将其标记一下。

#### 代码实现

+ 找到与第一个顶点相邻的所有顶点
+ 标记哪些顶点访问过
+ 需要一个辅助队列

#### 遍历的可变性

邻接矩阵：广度优先遍历序列唯一

邻接表：广度优先遍历序列不唯一

#### 复杂度分析

时间开销来自于访问顶点和边的开销

##### 邻接矩阵

访问每个顶点需要$|V|$的时间，总共有V个顶点。总的时间复杂度是$O(|V|^2)$

##### 邻接表

实现时间复杂度为$O(|V|+|E|)$   这里其实2E，但是尝试就省略了

#### 广度优先生成树

转为为层序遍历，在转换为树。

故邻接表来，生成的树不唯一。邻接矩阵是唯一的。

### 深度优先遍历

#### 与树的深度优先遍历之间的联系

+ 采用递归访问的方法
+ 但是由于树的特性，被访问过的结点一定是没有没有被访问过的结点。图就不一样了，有可能被访问过。
+ 设置一个visit数组

#### 算法实现

#### 复杂度分析(这种题目的分析不要从代码出发)

空间复杂度：来自函数调用栈，最坏情况，递归递归深度为$O(|V|)$;最好情况，$O(1)$.没有特殊情况，得答最坏的情况

**时间复杂度：访问各个结点所需要的时间+探索各个边所需要的时间**

邻接矩阵：$O(|V|^2)$

邻接表：$O(|V|+|E|)$

#### 深度优先生成树

和上面差不多

#### 图的遍历和图的连通性

调用BFS或者DFS的次数=连通分量数。

对于连通图，只调用一次。

如果是有向图，情况就复杂些。具体问题具体分析。

如果是强连通图，只需要调用一次。

## 图的相关应用

### 最小生成树

+ 含连通图的所有顶点，含尽可能少的边。少一条边会变成非连通，多一条边会形成回路。

+ **连通且代价最低**

+ 研究的对象是带权的连通无向图

#### Prim算法

**选顶点集合中与其最相近的边。**

从某个顶点开始构建生成树

每次将代价最小的纳入（**从已经构成的新树中找代价最小的边**）

直到所有的点都被纳入

时间复杂度：$O(|V|^2)$

适用于边稠密图

#### Kruskal算法

每次挑选一条权值最小的一条边，使得这两条边是连通的（原本已经连通的就不选），直到所有的结点都连通

时间复杂度：$O(|E|log_2|E|)$

使用于边稀疏图

### 最短路径

#### 单源最短路径问题

##### BFS

+ **只适用与不带权图**

##### DIJKSTRA

+ 适用于带权图
+ 初始化三个数组：
  + 标记各顶点是否已经找到最短路径
  + 最短路径长度
  + 路径上的前驱
+ 时间复杂度$O(|V|^2)$
+ 不适合用于负权值的带权图

#### 每一对顶点之间的最短路径

FLOYD

可以解决带负权值的问题

但不能解决有带“负权回路”的问题，会一直迭代下去

### 有向无环图表达式

+ 把各个操作数不重复的排成一排
+ 标出各个运算符的运算次序
+ 按顺序加入运算符（注意分层）
+ 从底向上逐层检查**同层的运算符**是否能合并。

### 拓扑排序

AOV网。用顶点表示活动的网。

一定是一个**有向无环图**（DAG）。

拓扑排序：找到做这些事情的先后顺序。

#### 拓扑排序的实现

+ 从AOV网络中找到的没有前驱的（入度为0）结点并输出
+ 从该网中删除该顶点和所有以它为起点的有向边
+ 重复上面两步，直到**AOV网络为空**或**当前网中不存在前驱结点**
  + 因为如果原图中存在回路，则就没法做到入度为0

#### 时间复杂度

邻接表

$O(|V|+|E|)$

邻接矩阵

$O(|V|^2)$

逆拓扑排序

### 关键路径

AOE。用边来表示活动。这些活动需要持续一段时间，事件是一瞬间的。

**点上的是事件，边上的是活动。**

从源点到汇点的路径可能有多条，**最大长度的路径是关键路径。关键路径上的活动是关键活动。**工程完成的**最短时间**就是关键路径的长度。

关键路径上的活动，**时间余量为0**（立即完成）

## 关于一些易混淆的点

### 最短路径

不能用于测试有没有回路

|            | DIJKSTRA                                                     | FLOYD                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 特点       | 单源最短路径<br />不能求带负权值路径                         | 任意两个顶点之间的最短路径<br />能求带负权值路径             |
| 时间复杂度 | 邻接表和邻接矩阵都是$O(|V|^2)$                               | $O(|V|^3)$                                                   |
| 算法思想   | 本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。 | ![image-20220731165450999](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220731165450999.png) |

### 最小生成树

|            | Prim                       | Kruskal                                    |
| ---------- | -------------------------- | ------------------------------------------ |
| 特点       | 找点                       | 找边                                       |
| 时间复杂度 | $O(|V|^2)$                 | $O(|E|log|E|)$                             |
| 算法思想   | 从顶点集合中找距离最近的点 | 不断选取当前未被选取过的且权值最小的一条边 |

### 拓扑排序

能够用于测试是否有回路

AOV。（根据点来，所以是AOV）

算法：见上

### 关键路径

能够用于测试是否有回路（有争议）

AOE。（根据边来）

算法思路：找出每个结点的最大的时间开销。