# 树与二叉树

[TOC]

## 树的基本概念

+ 除了根结点外，任何结点都有且仅有一个前驱。
+ 树是递归定义的数据结构，任何一个树都可以看做是根结点和若干**不相交**的子树构成的

### 基本术语

树的高度：树中结点的最大层数。（最上面是第一层）

祖先：结点K到根A的唯一**路径上的任意结点**

双亲：父亲结点

孩子结点：注意是直接相邻的

兄弟结点：拥有相同双亲

结点的度：树中一个结点的**孩子的个数**

树的度：树中**结点的最大度数**

**叶子结点：度数为0**

分支结点：度数大于0的结点

结点的高度：

结点的深度：从根结点开始自顶向下累加

结点的高度：从叶结点开始自底向上累加

有序树和无序树：

+ 有序 子树从左到右是有次序的，不能互换
+ 无序 可以互换

路径的长度：**边**的个数

森林：不相交的树的集合

| 度为m的树                                           | m叉树                          |
| --------------------------------------------------- | ------------------------------ |
| 任意结点的度<=m(最多有m个孩子)                      | 任意结点的度<=m(最多有m个孩子) |
| 至少有一个结点度=m（有m个孩子）                     | 允许所有结点的度都<m           |
| 一定是非空树，至少有m+1个结点（m个孩子+一个根结点） | 可以是空树                     |

高度为h的m叉树至少有h个结点。高度为h、度为m的树至少有h+m-1个结点。

### 树的性质

我觉得做这种题目 最好的办法就是特殊化，先特殊再一般

1. **树的结点数等于所有结点的度数之和加1**（就当做根节点最上面没有，这个公式常用来计算，建立度数与结点之间的等式）
2. 度数为m的树中第i层上至多有$m^{i-1}$个结点
3. 高度为h的m叉树至多有（$m^h-1/(m-1)$）个结点。（等比公式求和）
4. 具有n个结点的m叉树的最小高度为$log_m(n(m-1)+1)$(树往宽处长，这里我认为还是画图最简单)

## 二叉树的概念

### 二叉树的定义及其主要特性

+ 所有结点的度数都不超过2
+ 是有序树
+ 空树是二叉树
+ **二叉树的某个结点哪怕只有一个度，其孩子结点也得确定左右次序**

#### 几种特殊的二叉树：

+ 满二叉树
  + 每一层都含有最多的结点
  + 编号为i的结点，双亲为[i/2]。左孩子结点为2i,右孩子结点为2i+1。**向下取整**

+ 完全二叉树
  + **把满二叉树编号较大的一些结点给去掉（从右边开始去掉）**
  + 若i<=[n/2],则结点i为分支结点，否则为叶子结点
  + 叶子节点只看在层次最大的两层上出现
  + 若有度数为1的结点，则只**可能有一个**，且该结点**只有左孩子而无右孩子**

+ 二叉排序树
  + 左子树上所有结点的关键字均小于根结点的关键字
  + 右子树上所有结点的关键字均大于根结点的关键字
  + 左子树和右子树又各是一颗二叉排序树

+ 平衡二叉树
  + 树上任一结点的左子树和右子树的深度之差不超过1。

#### 二叉树的常考性质

+ 非空二叉树上的叶子结点数等于度数为2的结点数加1.即**$n_0=n_2+1$**,(由上面树的性质1推出)
+ **非空二叉树上第K层上至多有$2^{k-1}$个结点**
+ **高度为h的二叉树，至多有$2^h-1$个结点**
+ 偶数是左孩子，奇数是右孩子。
+ **结点i所在的层次为$[log_2{i}]+1$**
+ 具有n个结点的完全二叉树的高度为$[log_2(n+1)]$或$[log_2n]+1$

#### 完全二叉数的常考性质

由结点为n推出度为0，1，2的结点的个数为$n_0,n_1,n_2$。单分支结点只有可能为0，叶子结点和双分支结点的和一定是奇数

+ 完全二叉树**最多只有一个度为1的结点**，即$n_1=0或1$
+ $n_0=n_2+1 \rightarrow n_0+n_2$一定是奇数
  + 所以完全二叉树有2k个（偶数）个结点，则必有$n_1=1,n_0=k,n_2=k-1$
  + 所以完全二叉树有2k-1个（奇数）个结点，则必有$n_1=0,n_0=k,n_2=k-1$

### 二叉树的存储结构

#### 线性存储结构

注意从数组下标为1的开始存储。不然的话，寻找起来没法用性质。

若完全二叉树中共有n个结点，则

+ 判断i是否有左孩子？  
  + 2i<=n
+ 判断i是否有右孩子？
  + 2i+1<=n   
+ 判断i是否是叶子/分支结点？
  + i>[n/2]

二叉树的顺序存储结构适合存储完全二叉树

#### 链式存储结构

+ **在含有n个结点的二叉链表中，含有n+1个空链域**。（总共有n个结点，就有2n个指针域，有n-1个结点会被一个指针域所指向（根结点除外），所以会有n+1个空链域）

+ 找到左右孩子结点很简单，但是找到父节点很困难。如果需要经常使用的话，就可以定义一个指向父节点的指针

## 二叉树的遍历和线索二叉树

### 二叉树的遍历

空间复杂度$O(n)$

遍历时需要脑补出空节点

重点是求二叉树的遍历序列

我觉得可以用**递归的方法**来写。这样好一些

#### 先序遍历

得到的是前缀表达式

#### 中序遍历

得到的是中缀表达式

#### 后序遍历

得到的是后缀表达式

应用：求树的深度

#### 二叉树的层次遍历

算法思想：

+ 初始化一个辅助队列
+ 根结点入队
+ 若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾（如果有的话）
+ 重复3直到队列为空

#### 由遍历序列构造二叉树

若只给出一棵二叉树的 前中后层序比遍历序列中的一种，不能唯一确定一棵二叉树

+ 如果给出**两种**，就能唯一确定一棵树。（**一定要有中序**）
+ 关键在于**找出根节点**，根据中序序列划分左右子树

### 线索二叉树

+ 对于二叉树的遍历，每次都需要从根节点出发。（给出树中某个结点的指针，无法完成往后的遍历）
+ n个结点的二叉树，有n+1个空链域，可以用来记录前驱和后继的信息。（线索化）
+ 依照遍历的方式进行线索化

#### 实现

+ 增加两个int类型的tag
  + tag为0，表示指向的是结点的孩子
  + tag为1，表示指向的是结点的前驱或者后继。

