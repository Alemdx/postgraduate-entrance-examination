# 树与二叉树

[TOC]

## 树的基本概念

+ 除了根结点外，任何结点都有且仅有一个前驱。
+ 树是递归定义的数据结构，任何一个树都可以看做是根结点和若干**不相交**的子树构成的

### 基本术语

树的高度：树中结点的最大层数。（最上面是第一层）

祖先：结点K到根A的唯一**路径上的任意结点**

双亲：父亲结点

孩子结点：注意是直接相邻的

兄弟结点：拥有相同双亲

结点的度：树中一个结点的**孩子的个数**

树的度：树中**结点的最大度数**

**叶子结点：度数为0**

分支结点：度数大于0的结点

结点的高度：

结点的深度：从根结点开始自顶向下累加

结点的高度：从叶结点开始自底向上累加

有序树和无序树：

+ 有序 子树从左到右是有次序的，不能互换
+ 无序 可以互换

路径的长度：**边**的个数

森林：不相交的树的集合

| 度为m的树                                           | m叉树                          |
| --------------------------------------------------- | ------------------------------ |
| 任意结点的度<=m(最多有m个孩子)                      | 任意结点的度<=m(最多有m个孩子) |
| **至少有一个结点度=m（有m个孩子）**                 | **允许所有结点的度都<m**       |
| 一定是非空树，至少有m+1个结点（m个孩子+一个根结点） | 可以是空树                     |

高度为h的m叉树至少有h个结点。高度为h、度为m的树至少有h+m-1个结点。

### 树的性质

我觉得做这种题目 最好的办法就是特殊化，先特殊再一般

1. **树的结点数等于所有结点的度数之和加1**（就当做根节点最上面没有，这个公式常用来计算，建立度数与结点之间的等式）
2. 度数为m的树中第i层上至多有$m^{i-1}$个结点
3. 高度为h的m叉树至多有（$m^h-1/(m-1)$）个结点。（等比公式求和）
4. 具有n个结点的m叉树的最小高度为$log_m(n(m-1)+1)$(树往宽处长，这里我认为还是画图最简单)

## 二叉树的概念

### 二叉树的定义及其主要特性

+ 所有结点的度数都不超过2
+ 是有序树
+ 空树是二叉树
+ **二叉树的某个结点哪怕只有一个度，其孩子结点也得确定左右次序**

#### 几种特殊的二叉树：

+ 满二叉树
  + 每一层都含有最多的结点
  + 编号为i的结点，双亲为[i/2]。左孩子结点为2i,右孩子结点为2i+1。**向下取整**

+ 完全二叉树
  + **把满二叉树编号较大的一些结点给去掉（从右边开始去掉）**
  + 若i<=[n/2],则结点i为分支结点，否则为叶子结点
  + 叶子节点只看在层次最大的两层上出现
  + 若有度数为1的结点，则只**可能有一个**，且该结点**只有左孩子而无右孩子**

+ 二叉排序树
  + 左子树上所有结点的关键字均小于根结点的关键字
  + 右子树上所有结点的关键字均大于根结点的关键字
  + 左子树和右子树又各是一颗二叉排序树

+ 平衡二叉树
  + 树上任一结点的左子树和右子树的深度之差不超过1。

#### 二叉树的常考性质

+ 非空二叉树上的叶子结点数等于度数为2的结点数加1.即**$n_0=n_2+1$**,(由上面树的性质1推出)
+ **非空二叉树上第K层上至多有$2^{k-1}$个结点**
+ **高度为h的二叉树，至多有$2^h-1$个结点**
+ 偶数是左孩子，奇数是右孩子。
+ **结点i所在的层次为$[log_2{i}]+1$**
+ 具有n个结点的完全二叉树的高度为$[log_2(n+1)]$或$[log_2n]+1$

#### 完全二叉数的常考性质

由结点为n推出度为0，1，2的结点的个数为$n_0,n_1,n_2$。单分支结点只有可能为0，叶子结点和双分支结点的和一定是奇数

+ 完全二叉树**最多只有一个度为1的结点**，即$n_1=0或1$
+ $n_0=n_2+1 \rightarrow n_0+n_2$一定是奇数
  + 所以完全二叉树有2k个（偶数）个结点，则必有$n_1=1,n_0=k,n_2=k-1$
  + 所以完全二叉树有2k-1个（奇数）个结点，则必有$n_1=0,n_0=k,n_2=k-1$

### 二叉树的存储结构

#### 线性存储结构

注意从数组下标为1的开始存储。不然的话，寻找起来没法用性质。

若完全二叉树中共有n个结点，则

+ 判断i是否有左孩子？  
  + 2i<=n
+ 判断i是否有右孩子？
  + 2i+1<=n   
+ 判断i是否是叶子/分支结点？
  + i>[n/2]

二叉树的顺序存储结构适合存储完全二叉树

#### 链式存储结构

+ **在含有n个结点的二叉链表中，含有n+1个空链域**。（总共有n个结点，就有2n个指针域，有n-1个结点会被一个指针域所指向（根结点除外），所以会有n+1个空链域）

+ 找到左右孩子结点很简单，但是找到父节点很困难。如果需要经常使用的话，就可以定义一个指向父节点的指针

## 二叉树的遍历和线索二叉树

### 二叉树的遍历

空间复杂度$O(n)$

遍历时需要脑补出空节点

重点是求二叉树的遍历序列

我觉得可以用**递归的方法**来写。这样好一些

#### 先序遍历

得到的是前缀表达式

#### 中序遍历

得到的是中缀表达式

#### 后序遍历

得到的是后缀表达式

应用：求树的深度

#### 二叉树的层次遍历

算法思想：

+ 初始化一个辅助队列
+ 根结点入队
+ 若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾（如果有的话）
+ 重复3直到队列为空

#### 由遍历序列构造二叉树

若只给出一棵二叉树的 前中后层序比遍历序列中的一种，不能唯一确定一棵二叉树

+ 如果给出**两种**，就能唯一确定一棵树。（**一定要有中序**）
+ 关键在于**找出根节点**，根据中序序列划分左右子树

### 线索二叉树

+ 对于二叉树的遍历，每次都需要从根节点出发。（给出树中某个结点的指针，无法完成往后的遍历）
+ n个结点的二叉树，有n+1个空链域，可以用来记录前驱和后继的信息。（线索化）
+ 依照遍历的方式进行线索化

#### 实现

+ 增加两个int类型的tag
  + tag为0，表示指向的是结点的孩子
  + tag为1，表示指向的是结点的前驱或者后继。
+ 易错点
  + 最后一个结点的rchild、rtag的处理
  + 先序线索化中，注意处理爱滴魔力转圈圈问题，当Ltag==0时，才能对左子树先序线索化（中序和后序不会出现这种问题）


|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| ------ | -------------- | -------------- | -------------- |
| 找前驱 | √              | ×              | √              |
| 找后继 | √              | √              | ×              |

重点：

+ 手算 找前驱、找后继

## 树、森林

### 树的存储结构

#### 双亲表示法

+ 每个结点中保存指向双亲的“指针”

+ 找到指定结点的孩子只能从头遍历

#### 孩子表示法（顺序存储+链式存储）

+ 找孩子是很方便的，找双亲不方便

#### 孩子兄弟表示法

+ 包含第一个孩子和**右兄弟指针**（右兄弟是第一个孩子的右兄弟，而不是双亲结点的兄弟，**右指针指向第一个孩子**）

+ 可以实现将树转化为二叉树，就可以使用二叉树的操作

### 森林和二叉树的转换

![image-20220726153924754](https://raw.githubusercontent.com/Alemdx/pic-bed/master/math2/image-20220726153924754.png)

树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻的右兄弟。（就是前面的孩子兄弟表示法）

画法：

+ 在兄弟结点之间加一根连线
+ 只保留与第一个孩子的连线，其他孩子的连线全部抹掉
+ 以树根为轴心，转动$45度$

### 树和森林的遍历

#### 树的遍历

##### 先根遍历

树的先根遍历序列与这棵树相应二叉树的**先序序列相同**。

DFS

##### 后根遍历

**树的后根遍历**与这棵树相对应**二叉树的中序序列**相同。从

DFS

##### 层次遍历

使用队列实现

BFS

#### 森林的遍历

##### 森林的先序遍历

+ 效果等同于一次对各个子树进行先根遍历的效果
+ 效果等同于对二叉树的先序遍历

##### 中序遍历森林

+ 效果等同于依次对二叉树的中序遍历

## 树和二叉树的应用

### 哈夫曼树

结点的权：有某种现实含义的数值

结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该节点上权值的乘积。（路径长度*该节点权值）

树的带权路径长度：树中所有**叶结点**的带权路径长度之和

#### 哈夫曼树的定义

在含有n个带权叶结点的二叉树中，其中**带权路径长度最小的二叉树**称为哈夫曼树，也称最优二叉树。

#### 哈夫曼树的构造

+ 自底向上，权值最小的先合并，权值大的在上面。（只计算叶结点，所以合并得出的结点就无所谓了）

+ 哈夫曼树的构造不唯一

#### 哈夫曼编码

+ 一般是左0右1

前缀码：是指对字符集进行编码时，要求字符集中任一字符的编码都**不是其它字符的编码的前缀**

前缀编码，不会产生歧义。

可以用于数据的压缩

