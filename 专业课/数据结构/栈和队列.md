[TOC]

# 栈

## 栈的基本概念

+ 只允许在一端进行插入或删除操作的线性表。（逻辑上是线性结构）

+ 是一种先进后出的数据结构（LIFO）
+ 无论是什么方法，时间复杂度都是$O(1)$

### 共享栈

+ 拥有两个指针，一个指向栈顶，一个指向栈底。
+ 从两头向中间移动
+ 栈满的判定
  + top0-top1=1

### 栈的链式存储结构

+ 入栈和出栈都在链表的表头进行。
+ 不同链表实现栈的链式存储结构其优劣的比较(P68 07)
  + 双循环链表
  + 单循环链表

### 卡特兰数

出栈元素不同的排列个数

${1 \over {n+1}}C_{2n}^n $

## 栈的基本操作

Pop函数会将元素弹出栈并**返回**。

GetTop获取元素，并不会删除。

## 栈中应当注意的问题

+ 区分栈顶和栈底。（只有栈顶一个指针）
+ 在数组表示的栈中，注意栈顶的位置是在哪（-1还是0）
+ 出栈操作中，只是逻辑上将该数删除了，实际上数还在内存中。因为本质上只是改变了指针的位置。
+ 栈只会出现上溢的问题

## 栈在表达式求值中的应用

+ 波兰表达式=前缀表达式 ；逆波兰表达式=后缀表达式  

+ 重要的点在于屡清楚中缀表达式运行的先后次序。因为有的时候运算顺序是不唯一的，表达式也就不唯一。但是算法的要求是，对于相同的输入，要能够呈现相同的输出（确定性），于是就必须执行左优先原则（对于后缀表达式）或者右优先原则（对于前缀表达式）。
  + 左优先和右优先的意思是，同一个表达式中，有些步骤的运算优先级是相同的。左优先就是先从左边开始，反之亦然。
+ 这里要千万注意**左右位置别放错**。求前后缀表达式的时候
+ 递归、进制转换、迷宫求解（我决定这里是BFS啊？不是栈）

### 用栈实现后缀表达式的计算

+ **从左往右**扫描下一个元素，直到处理完所有的元素。
+ 如扫描到操作数则压入栈，回到第一步；否则执行第三步
+ 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到第一步（在后缀表达式中，**先出栈的是右操作数，后出栈的是左操作数**）这里其实用手模拟一下就好些了。

### 用栈实现前缀表达式的计算

+ **从右往左**扫描下一个元素，直到处理完所有元素。
+ 若扫描到操作数则压入栈，并回到上一步，否则执行下一步。
+ 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到第一步。（这里需要注意，**先出栈的是左操作数，后出栈的是右操作数**）

### 用栈实现中缀表达式转后缀表达式

+ 初始化一个栈，用于**保存暂时还不能确定运算顺序的运算符**。
+ 从左到右处理各个元素，直到末尾。可能遇到三种情况：
  + 遇到**操作数**，直接加入后缀表达式。
  + 遇到**界限符**。遇到“（”直接入栈；**遇到“）”，则一次弹出栈内运算符并加入后缀表达式**，直到弹出“（”为止。注意括号不加入后缀表达式。
  + 遇到**运算符**。一次**弹出栈中优先级高于或等于当前运算符的所有运算符**（比如说遇到乘法时，里面的减法就不能弹出栈），并加入后缀表达式，若碰到“（”或栈空则停止.**之后再把当前运算符入栈**。（**这里王道咸鱼视频有问题！！存疑**）
+ 按上述方法处理完所有的字符后，将栈中剩余运算符一次弹出，并加入后缀表达式。

### 用栈实现中缀表达式的求值

其实就是把上面的两个算法相结合一下就可以了。王道P95 04

+ 初始化两个栈，**操作数栈**（后缀表达式的计算）和**运算符栈**（中缀转后缀）
+ 若扫描到操作数，压入操作数栈
+ 若扫描到运算符或界限符，则按中缀转后缀的相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应的运算，运算结果再压回操作数栈）

### 栈在递归中的调用

函数调用的特点是：最后被调用的函数最先执行结束（LIFO）。这就和栈的原理相似。

# 队列

## 队列的基本概念

+ 只允许在表的一端进行插入，而在表的另一端进行删除
+ 操作特性是先进先出（FIFO）

## 队列的基本操作

## 队列的存储结构

### 顺序存储结构

+ 采用的是数组的方式实现
+ **需要注意的是头尾指针具体指向的位置**(这会影响到队尾元素的判定)
+ 空队列：$Q.front=Q.rear=0$
+ 入队操作：$Q.rear=(Q.rear+1) \% Maxsize$
+ 出队操作：$Q.front=(Q.front+1) \% Maxsize$
+ 队列长度：$(Q.rear+MaxSize-Q.front)\% Maxsize$
  + 南软的书上有加一


注：以上的这些方法，无论对于哪种顺序存储的队列，都适用。对于队满的判断，这里不能确定。

#### 三种区分对空队满的方式

+ 牺牲一个单元来区分队空与队满
  + 队满条件：$(Q.rear+1) \%MaxSize==Q.front$

+ 新增成员变量
+ 新增tag

### 链式存储结构

+ 存在队列满产生溢出的问题

#### 双端队列

+ 输出受限的双端队列
  + 两端插入，一端删除
+ 输入受限的双端队列
  + 一端插入，两端删除

## 队列在层次遍历中的应用（mark）

+ 树的层次遍历
+ 图的广度优先遍历
+ 队列在操作系统中的应用
  + 进程争抢资源，先来先服务(FCFS)。页面替换算法。
+ 缓冲区

